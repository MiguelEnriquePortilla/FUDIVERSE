# üß† FUDIVERSE - SCALABLE INTELLIGENCE ARCHITECTURE
## "From 1 Restaurant to 1 Million: Building the World's Most Intelligent Restaurant AI"

**Version:** 2.0 - Scalable Intelligence  
**Last Updated:** May 30, 2025  
**Status:** Production Foundation ‚Üí Enterprise Scale  

---

## üìã TABLE OF CONTENTS

1. [Executive Summary](#executive-summary)
2. [Current State Assessment](#current-state-assessment)  
3. [Scalable Intelligence Architecture](#scalable-intelligence-architecture)
4. [Implementation Phases](#implementation-phases)
5. [Phase 1: Foundation (2 Weeks)](#phase-1-foundation)
6. [Phase 2: AI Enhancement (4 Weeks)](#phase-2-ai-enhancement)
7. [Phase 3: Scale (8 Weeks)](#phase-3-scale)
8. [Phase 4: Network Intelligence (12 Weeks)](#phase-4-network-intelligence)
9. [Developer Handoff Guide](#developer-handoff-guide)
10. [Monitoring & Success Metrics](#monitoring--success-metrics)

---

## üéØ EXECUTIVE SUMMARY

### **THE VISION**
FUDIVERSE is evolving from a single-restaurant neural AI to the world's first **scalable restaurant intelligence network** capable of serving **1 million+ restaurants** with personalized, learning AI assistants that grow smarter with every interaction.

### **THE PROBLEM WE'RE SOLVING**
- **Current Limitation:** Processing 1000 transactions max, 30-day windows only
- **Enterprise Need:** Multi-year analysis, predictive insights, cross-restaurant learning
- **Scale Target:** 1M+ restaurants √ó 100K+ transactions each = 100B+ data points

### **THE SOLUTION**
**Intelligent Data Architecture** that pre-processes, learns patterns, and delivers instant insights while maintaining perfect data isolation and continuous learning capabilities.

### **CORE PRINCIPLES**
1. **Data ‚Üí Logic ‚Üí Training ‚Üí Growth** (like human intelligence)
2. **Restaurant data isolation** (never mix data between restaurants)
3. **Background intelligence processing** (insights ready before questions asked)
4. **Continuous pattern learning** (FUDI gets smarter every day)
5. **Network effect intelligence** (collective learning, individual personalization)

---

## üìä CURRENT STATE ASSESSMENT

### ‚úÖ **WHAT WORKS (FOUNDATION COMPLETE)**

#### **Neural Architecture** 
```
‚úÖ FudiBrain neural orchestrator functional
‚úÖ ProductLobe + PaymentLobe processing real data  
‚úÖ 1000+ transactions analyzed correctly
‚úÖ Bourdain personality + FudiResto‚Ñ¢Ô∏è tone
‚úÖ Neural insights ‚Üí Claude thinking pipeline
‚úÖ Real-time response generation (<3 seconds)
```

#### **Data Integration**
```
‚úÖ Supabase connected with real restaurant data
‚úÖ Transactions, products, customers tables populated
‚úÖ Real-time POS data sync capability
‚úÖ 1461+ product items processed successfully
‚úÖ Accurate calculations (203 units = 6.8 daily average)
```

#### **Technical Infrastructure**
```
‚úÖ Next.js frontend deployed on Vercel
‚úÖ API routes functional and scalable
‚úÖ Error handling and fallback systems
‚úÖ Environment configuration proper
‚úÖ Git workflow and deployment pipeline
```

### ‚ùå **CURRENT LIMITATIONS (ENTERPRISE GAPS)**

#### **Data Processing Constraints**
```
‚ùå Hard limit: 1000 transactions per query
‚ùå Time window: 30 days maximum  
‚ùå No historical pattern analysis
‚ùå No predictive capabilities
‚ùå No cross-restaurant benchmarking
```

#### **Scalability Issues**
```
‚ùå Real-time processing only (no pre-computation)
‚ùå No data aggregation strategy
‚ùå No intelligent caching system
‚ùå No background processing jobs
‚ùå Single-tenant architecture only
```

#### **Intelligence Limitations**
```
‚ùå No pattern learning system
‚ùå No seasonal trend detection
‚ùå No customer behavior analysis
‚ùå No inventory prediction
‚ùå No industry benchmarking
```

### üìà **GAP ANALYSIS**

| Current Capability | Enterprise Requirement | Gap |
|-------------------|------------------------|-----|
| 1K transactions | 100K+ transactions | 100x scale |
| 30 days history | 2+ years analysis | 24x time depth |
| 1 restaurant | 1M restaurants | 1,000,000x multi-tenant |
| Basic insights | Predictive analytics | Intelligence evolution |
| Static responses | Learning conversations | Adaptive AI |

---

## üèóÔ∏è SCALABLE INTELLIGENCE ARCHITECTURE

### **üß† LAYER 1: INTELLIGENT DATA FOUNDATION**

```
RAW DATA LAYER (Current)
‚îú‚îÄ‚îÄ transactions (1M+ per restaurant)
‚îú‚îÄ‚îÄ products (100+ per restaurant) 
‚îú‚îÄ‚îÄ customers (10K+ per restaurant)
‚îú‚îÄ‚îÄ employees, inventory, suppliers
‚îî‚îÄ‚îÄ real_time_pos_sync

INTELLIGENT AGGREGATION LAYER (New)
‚îú‚îÄ‚îÄ intelligent_metrics (pre-calculated insights)
‚îú‚îÄ‚îÄ pattern_embeddings (AI-discovered patterns)  
‚îú‚îÄ‚îÄ fudi_learned_patterns (restaurant-specific learning)
‚îú‚îÄ‚îÄ industry_benchmarks (cross-restaurant intelligence)
‚îî‚îÄ‚îÄ prediction_models (future forecasting)
```

### **ü§ñ LAYER 2: BACKGROUND INTELLIGENCE ENGINE**

```
NIGHTLY PROCESSING PIPELINE
‚îú‚îÄ‚îÄ 1. Data Aggregation (metrics calculation)
‚îú‚îÄ‚îÄ 2. Pattern Discovery (AI pattern detection)  
‚îú‚îÄ‚îÄ 3. Insight Generation (pre-calculate common queries)
‚îú‚îÄ‚îÄ 4. Quality Scoring (confidence metrics)
‚îú‚îÄ‚îÄ 5. Learning Updates (improve FUDI intelligence)
‚îî‚îÄ‚îÄ 6. Prediction Refresh (update forecasts)

REAL-TIME PROCESSING
‚îú‚îÄ‚îÄ Instant insight delivery (cached results)
‚îú‚îÄ‚îÄ Dynamic question handling (on-demand analysis)
‚îú‚îÄ‚îÄ Pattern matching (vector similarity search)
‚îî‚îÄ‚îÄ Conversation learning (interaction improvement)
```

### **‚ö° LAYER 3: SUPABASE AI OPTIMIZATION**

```
AI-POWERED DATABASE FUNCTIONS
‚îú‚îÄ‚îÄ calculate_product_intelligence() (advanced analytics)
‚îú‚îÄ‚îÄ detect_seasonal_patterns() (time series analysis)
‚îú‚îÄ‚îÄ predict_inventory_needs() (forecasting)
‚îú‚îÄ‚îÄ benchmark_performance() (industry comparison)
‚îî‚îÄ‚îÄ generate_recommendations() (actionable insights)

VECTOR EMBEDDINGS
‚îú‚îÄ‚îÄ Pattern similarity matching
‚îú‚îÄ‚îÄ Restaurant profile embeddings  
‚îú‚îÄ‚îÄ Question intent vectors
‚îî‚îÄ‚îÄ Response quality vectors
```

### **üîí LAYER 4: MULTI-TENANT ISOLATION**

```
SCALABLE DATA ARCHITECTURE
‚îú‚îÄ‚îÄ Restaurant ID sharding (consistent hashing)
‚îú‚îÄ‚îÄ Cache namespacing (Redis per restaurant)
‚îú‚îÄ‚îÄ Query isolation (guaranteed data separation)
‚îú‚îÄ‚îÄ Background job isolation (per-restaurant processing)
‚îî‚îÄ‚îÄ Performance monitoring (per-tenant metrics)

1 MILLION RESTAURANT CAPACITY
‚îú‚îÄ‚îÄ Horizontal sharding strategy
‚îú‚îÄ‚îÄ Load balancing algorithms
‚îú‚îÄ‚îÄ Memory optimization techniques
‚îî‚îÄ‚îÄ Query performance optimization
```

### **üß† LAYER 5: FUDI LEARNING SYSTEM**

```
CONTINUOUS LEARNING PIPELINE
‚îú‚îÄ‚îÄ Interaction Analysis (question ‚Üí response ‚Üí feedback)
‚îú‚îÄ‚îÄ Pattern Reinforcement (successful conversation patterns)
‚îú‚îÄ‚îÄ Style Adaptation (restaurant-specific communication)
‚îú‚îÄ‚îÄ Accuracy Improvement (data quality learning)
‚îî‚îÄ‚îÄ Knowledge Updates (industry trends integration)

PERSONALIZATION ENGINE
‚îú‚îÄ‚îÄ Restaurant personality profiles
‚îú‚îÄ‚îÄ Industry-specific vocabulary
‚îú‚îÄ‚îÄ Communication style preferences
‚îî‚îÄ‚îÄ Decision-making patterns
```

### **üåç LAYER 6: NETWORK INTELLIGENCE**

```
COLLECTIVE INTELLIGENCE
‚îú‚îÄ‚îÄ Cross-restaurant pattern discovery
‚îú‚îÄ‚îÄ Industry benchmark generation
‚îú‚îÄ‚îÄ Best practice identification
‚îî‚îÄ‚îÄ Trend forecasting (market-wide)

KNOWLEDGE DISTRIBUTION
‚îú‚îÄ‚îÄ Global pattern ‚Üí Local adaptation
‚îú‚îÄ‚îÄ Industry insights ‚Üí Restaurant-specific
‚îú‚îÄ‚îÄ Network learning ‚Üí Individual improvement
‚îî‚îÄ‚îÄ Collective wisdom ‚Üí Personal intelligence
```

---

## üöÄ IMPLEMENTATION PHASES

### **PHASE OVERVIEW**

```
PHASE 1: Foundation (2 weeks)
‚îú‚îÄ‚îÄ Intelligent metrics system
‚îú‚îÄ‚îÄ Background processing jobs  
‚îú‚îÄ‚îÄ Pattern detection basics
‚îî‚îÄ‚îÄ TARGET: 10K+ transactions processed instantly

PHASE 2: AI Enhancement (4 weeks)  
‚îú‚îÄ‚îÄ Supabase AI functions
‚îú‚îÄ‚îÄ Vector embeddings system
‚îú‚îÄ‚îÄ Learning pattern storage
‚îî‚îÄ‚îÄ TARGET: Restaurant-specific pattern learning

PHASE 3: Scale (8 weeks)
‚îú‚îÄ‚îÄ Multi-tenant architecture
‚îú‚îÄ‚îÄ Sharding implementation  
‚îú‚îÄ‚îÄ Performance optimization
‚îî‚îÄ‚îÄ TARGET: 1000+ restaurants supported

PHASE 4: Network Intelligence (12 weeks)
‚îú‚îÄ‚îÄ Cross-restaurant learning
‚îú‚îÄ‚îÄ Industry benchmarking
‚îú‚îÄ‚îÄ Predictive analytics
‚îî‚îÄ‚îÄ TARGET: 1M+ restaurant capacity
```

---

## üîß PHASE 1: FOUNDATION (2 WEEKS)

### **WEEK 1: INTELLIGENT METRICS SYSTEM**

#### **DAY 1-2: Core Tables Creation**

##### **Prerequisites Check:**
```bash
# Verify current system status
- [ ] Supabase access confirmed  
- [ ] Current transaction count > 1000
- [ ] Restaurant ID format verified
- [ ] ProductAnalyzer functioning (203 units confirmed)
```

##### **Step 1: Create Intelligent Metrics Table**
```sql
-- üéØ COPY-PASTE INTO SUPABASE SQL EDITOR
CREATE TABLE intelligent_metrics (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id UUID NOT NULL,
  metric_type TEXT NOT NULL, -- 'product_performance', 'customer_behavior', 'seasonal_patterns'
  time_dimension TEXT NOT NULL, -- 'daily', 'weekly', 'monthly', 'quarterly', 'yearly'
  time_period DATE NOT NULL,
  dimensions JSONB NOT NULL, -- {product_id: 212, category: 'pollo', subcategory: 'rostizado'}
  metrics JSONB NOT NULL, -- {quantity: 1113, revenue: 224000, growth_rate: 15.2, margin: 25.5}
  insights JSONB, -- Pre-calculated insights for FUDI
  confidence_score FLOAT DEFAULT 1.0, -- Data quality confidence (0.0-1.0)
  processing_version TEXT DEFAULT 'v1.0', -- Track processing algorithm version
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Indexes for performance
  CONSTRAINT intelligent_metrics_restaurant_id_fkey 
    FOREIGN KEY (restaurant_id) REFERENCES restaurants(id)
);

-- Create performance indexes
CREATE INDEX idx_intelligent_metrics_restaurant_time 
  ON intelligent_metrics(restaurant_id, time_dimension, time_period);
CREATE INDEX idx_intelligent_metrics_type 
  ON intelligent_metrics(restaurant_id, metric_type);
CREATE INDEX idx_intelligent_metrics_confidence 
  ON intelligent_metrics(confidence_score) WHERE confidence_score >= 0.8;

-- Enable Row Level Security
ALTER TABLE intelligent_metrics ENABLE ROW LEVEL SECURITY;

-- Create RLS policy for restaurant data isolation
CREATE POLICY intelligent_metrics_restaurant_isolation 
  ON intelligent_metrics FOR ALL 
  USING (restaurant_id = current_setting('app.restaurant_id')::UUID);
```

##### **Validation Step 1:**
```sql
-- ‚úÖ Verify table creation
\d intelligent_metrics

-- Expected output should show:
-- - All columns present
-- - Indexes created  
-- - Foreign key constraint active
-- - RLS enabled

-- Test insert
INSERT INTO intelligent_metrics (
  restaurant_id,
  metric_type,
  time_dimension,
  time_period,
  dimensions,
  metrics
) VALUES (
  '13207c90-2ea6-4aa0-bfac-349753d24ea4',
  'product_performance',
  'monthly',
  '2025-05-01',
  '{"product_id": 212, "product_name": "PQ2 UN POLLO ROSTIZADO"}',
  '{"quantity": 1113, "revenue": 224077, "avg_price": 209}'
);

-- ‚úÖ Verify insert worked
SELECT * FROM intelligent_metrics LIMIT 1;
```

##### **Step 2: Create Pattern Learning Table**
```sql
-- üß† PATTERN LEARNING STORAGE
CREATE TABLE fudi_learned_patterns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id UUID NOT NULL,
  pattern_type TEXT NOT NULL, -- 'seasonal', 'day_of_week', 'weather_correlation', 'promotional'
  pattern_name TEXT NOT NULL, -- Human-readable pattern name
  pattern_data JSONB NOT NULL, -- The actual pattern discovered
  strength FLOAT NOT NULL DEFAULT 0.0, -- How strong/reliable (0.0-1.0)
  confidence FLOAT NOT NULL DEFAULT 0.0, -- AI confidence (0.0-1.0)
  impact_score FLOAT DEFAULT 0.0, -- Business impact score
  first_detected TIMESTAMPTZ DEFAULT NOW(),
  last_validated TIMESTAMPTZ DEFAULT NOW(),
  times_confirmed INTEGER DEFAULT 1,
  times_failed INTEGER DEFAULT 0,
  
  -- Pattern metadata
  sample_size INTEGER, -- How many data points support this pattern
  date_range_start DATE,
  date_range_end DATE,
  
  -- Learning tracking
  fudi_learning_version TEXT DEFAULT 'v1.0',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  CONSTRAINT fudi_learned_patterns_restaurant_id_fkey 
    FOREIGN KEY (restaurant_id) REFERENCES restaurants(id)
);

-- Performance indexes
CREATE INDEX idx_fudi_patterns_restaurant_type 
  ON fudi_learned_patterns(restaurant_id, pattern_type);
CREATE INDEX idx_fudi_patterns_strength 
  ON fudi_learned_patterns(strength) WHERE strength >= 0.7;
CREATE INDEX idx_fudi_patterns_confidence 
  ON fudi_learned_patterns(confidence) WHERE confidence >= 0.8;

-- RLS
ALTER TABLE fudi_learned_patterns ENABLE ROW LEVEL SECURITY;
CREATE POLICY fudi_patterns_restaurant_isolation 
  ON fudi_learned_patterns FOR ALL 
  USING (restaurant_id = current_setting('app.restaurant_id')::UUID);
```

##### **Validation Step 2:**
```sql
-- Test pattern storage
INSERT INTO fudi_learned_patterns (
  restaurant_id,
  pattern_type,
  pattern_name,
  pattern_data,
  strength,
  confidence
) VALUES (
  '13207c90-2ea6-4aa0-bfac-349753d24ea4',
  'day_of_week',
  'Friday Pollo Peak',
  '{"day": "friday", "product_id": 212, "avg_multiplier": 1.4, "peak_hours": [19, 20, 21]}',
  0.85,
  0.92
);

-- ‚úÖ Verify pattern storage
SELECT pattern_name, pattern_type, strength, confidence 
FROM fudi_learned_patterns;
```

#### **DAY 3-4: Background Processing Framework**

##### **Step 3: Create Background Intelligence Engine**
```javascript
// üìÅ services/intelligence/BackgroundIntelligenceEngine.js

const { createClient } = require('@supabase/supabase-js');

class BackgroundIntelligenceEngine {
  constructor() {
    this.supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    this.version = 'v1.0';
  }

  // üéØ MAIN ORCHESTRATOR
  async processAllRestaurants() {
    console.log('üß† Starting background intelligence processing...');
    
    const restaurants = await this.getActiveRestaurants();
    console.log(`üìä Processing ${restaurants.length} restaurants`);
    
    for (const restaurant of restaurants) {
      try {
        await this.processRestaurantIntelligence(restaurant.id);
        console.log(`‚úÖ Completed: ${restaurant.id}`);
      } catch (error) {
        console.error(`‚ùå Failed: ${restaurant.id}`, error);
      }
    }
    
    console.log('üéâ Background processing complete');
  }

  // üè™ PROCESS SINGLE RESTAURANT
  async processRestaurantIntelligence(restaurantId) {
    console.log(`üß† Processing intelligence for ${restaurantId}`);
    
    // Set restaurant context for RLS
    await this.supabase.rpc('set_config', {
      setting_name: 'app.restaurant_id',
      setting_value: restaurantId
    });
    
    // 1. Generate intelligent metrics
    await this.generateIntelligentMetrics(restaurantId);
    
    // 2. Discover patterns
    await this.discoverPatterns(restaurantId);
    
    // 3. Generate insights
    await this.generateInsights(restaurantId);
    
    // 4. Update confidence scores
    await this.updateConfidenceScores(restaurantId);
    
    console.log(`‚úÖ Intelligence processing complete for ${restaurantId}`);
  }

  // üìä GENERATE INTELLIGENT METRICS
  async generateIntelligentMetrics(restaurantId) {
    console.log('üìä Generating intelligent metrics...');
    
    // Product performance metrics (daily, weekly, monthly)
    await this.generateProductMetrics(restaurantId);
    
    // Customer behavior metrics
    await this.generateCustomerMetrics(restaurantId);
    
    // Seasonal pattern metrics
    await this.generateSeasonalMetrics(restaurantId);
    
    console.log('‚úÖ Intelligent metrics generated');
  }

  async generateProductMetrics(restaurantId) {
    // Get last 90 days of transaction data
    const { data: transactions } = await this.supabase
      .from('transactions')
      .select('*')
      .eq('restaurant_id', restaurantId)
      .gte('transaction_date', new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString())
      .limit(50000); // Higher limit for background processing

    if (!transactions || transactions.length === 0) return;

    // Extract all items
    const allItems = [];
    transactions.forEach(t => {
      if (t.items && Array.isArray(t.items)) {
        t.items.forEach(item => {
          allItems.push({
            product_id: item.product_id,
            quantity: item.num || 1,
            price: parseFloat(item.product_sum || 0),
            date: t.transaction_date,
            transaction_id: t.pos_transaction_id
          });
        });
      }
    });

    // Group by product and time periods
    const productMetrics = this.aggregateProductMetrics(allItems);
    
    // Store metrics for each time dimension
    for (const [productId, metrics] of Object.entries(productMetrics)) {
      // Daily metrics (last 30 days)
      for (const [date, dailyMetrics] of Object.entries(metrics.daily)) {
        await this.storeIntelligentMetric({
          restaurant_id: restaurantId,
          metric_type: 'product_performance',
          time_dimension: 'daily',
          time_period: date,
          dimensions: {
            product_id: parseInt(productId),
            product_name: metrics.product_name
          },
          metrics: dailyMetrics,
          confidence_score: this.calculateConfidenceScore(dailyMetrics)
        });
      }

      // Weekly metrics
      for (const [week, weeklyMetrics] of Object.entries(metrics.weekly)) {
        await this.storeIntelligentMetric({
          restaurant_id: restaurantId,
          metric_type: 'product_performance',
          time_dimension: 'weekly',
          time_period: week,
          dimensions: {
            product_id: parseInt(productId),
            product_name: metrics.product_name
          },
          metrics: weeklyMetrics,
          confidence_score: this.calculateConfidenceScore(weeklyMetrics)
        });
      }

      // Monthly metrics
      for (const [month, monthlyMetrics] of Object.entries(metrics.monthly)) {
        await this.storeIntelligentMetric({
          restaurant_id: restaurantId,
          metric_type: 'product_performance',
          time_dimension: 'monthly',
          time_period: month,
          dimensions: {
            product_id: parseInt(productId),
            product_name: metrics.product_name
          },
          metrics: monthlyMetrics,
          confidence_score: this.calculateConfidenceScore(monthlyMetrics)
        });
      }
    }
  }

  // üîç PATTERN DISCOVERY
  async discoverPatterns(restaurantId) {
    console.log('üîç Discovering patterns...');
    
    // Day of week patterns
    await this.discoverDayOfWeekPatterns(restaurantId);
    
    // Seasonal patterns
    await this.discoverSeasonalPatterns(restaurantId);
    
    // Peak hour patterns
    await this.discoverPeakHourPatterns(restaurantId);
    
    console.log('‚úÖ Pattern discovery complete');
  }

  async discoverDayOfWeekPatterns(restaurantId) {
    // Get metrics by day of week
    const { data: dailyMetrics } = await this.supabase
      .from('intelligent_metrics')
      .select('*')
      .eq('restaurant_id', restaurantId)
      .eq('metric_type', 'product_performance')
      .eq('time_dimension', 'daily');

    if (!dailyMetrics || dailyMetrics.length === 0) return;

    // Analyze day of week patterns for each product
    const productDayPatterns = {};
    
    dailyMetrics.forEach(metric => {
      const productId = metric.dimensions.product_id;
      const date = new Date(metric.time_period);
      const dayOfWeek = date.getDay(); // 0 = Sunday, 6 = Saturday
      const quantity = metric.metrics.quantity || 0;

      if (!productDayPatterns[productId]) {
        productDayPatterns[productId] = {
          product_name: metric.dimensions.product_name,
          days: [0, 0, 0, 0, 0, 0, 0], // Sunday to Saturday
          counts: [0, 0, 0, 0, 0, 0, 0]
        };
      }

      productDayPatterns[productId].days[dayOfWeek] += quantity;
      productDayPatterns[productId].counts[dayOfWeek]++;
    });

    // Calculate averages and detect patterns
    for (const [productId, data] of Object.entries(productDayPatterns)) {
      const averages = data.days.map((total, day) => 
        data.counts[day] > 0 ? total / data.counts[day] : 0
      );

      // Find peak day
      const maxAverage = Math.max(...averages);
      const peakDay = averages.indexOf(maxAverage);
      const overallAverage = averages.reduce((sum, avg) => sum + avg, 0) / 7;
      
      // Calculate pattern strength
      const peakMultiplier = maxAverage / (overallAverage || 1);
      const strength = Math.min((peakMultiplier - 1) / 2, 1); // Normalize to 0-1

      if (strength >= 0.3) { // Only store significant patterns
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        
        await this.storePattern({
          restaurant_id: restaurantId,
          pattern_type: 'day_of_week',
          pattern_name: `${data.product_name} - ${dayNames[peakDay]} Peak`,
          pattern_data: {
            product_id: parseInt(productId),
            product_name: data.product_name,
            peak_day: peakDay,
            peak_day_name: dayNames[peakDay],
            peak_multiplier: peakMultiplier,
            daily_averages: averages,
            baseline_average: overallAverage
          },
          strength: strength,
          confidence: this.calculatePatternConfidence(data.counts, strength)
        });
      }
    }
  }

  // üíæ UTILITY FUNCTIONS
  async getActiveRestaurants() {
    const { data } = await this.supabase
      .from('restaurants')
      .select('id, name')
      .eq('active', true);
    
    return data || [];
  }

  async storeIntelligentMetric(metric) {
    const { error } = await this.supabase
      .from('intelligent_metrics')
      .upsert({
        ...metric,
        processing_version: this.version,
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'restaurant_id,metric_type,time_dimension,time_period,dimensions'
      });

    if (error) {
      console.error('Error storing metric:', error);
    }
  }

  async storePattern(pattern) {
    const { error } = await this.supabase
      .from('fudi_learned_patterns')
      .upsert({
        ...pattern,
        fudi_learning_version: this.version,
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'restaurant_id,pattern_type,pattern_name'
      });

    if (error) {
      console.error('Error storing pattern:', error);
    }
  }

  calculateConfidenceScore(metrics) {
    // Simple confidence calculation based on sample size and consistency
    const sampleSize = metrics.transaction_count || 1;
    const sizeScore = Math.min(sampleSize / 100, 1); // 100+ transactions = full confidence
    
    return Math.max(sizeScore, 0.1); // Minimum 10% confidence
  }

  calculatePatternConfidence(counts, strength) {
    const totalSamples = counts.reduce((sum, count) => sum + count, 0);
    const sampleScore = Math.min(totalSamples / 50, 1); // 50+ samples = full confidence
    const strengthScore = strength;
    
    return (sampleScore + strengthScore) / 2;
  }

  // üìä DATA AGGREGATION HELPERS
  aggregateProductMetrics(items) {
    const productMetrics = {};
    
    items.forEach(item => {
      const productId = item.product_id;
      const date = new Date(item.date);
      const dateStr = date.toISOString().split('T')[0];
      const weekStr = this.getWeekString(date);
      const monthStr = date.toISOString().substring(0, 7);

      if (!productMetrics[productId]) {
        productMetrics[productId] = {
          product_name: `Product ${productId}`,
          daily: {},
          weekly: {},
          monthly: {}
        };
      }

      // Daily aggregation
      if (!productMetrics[productId].daily[dateStr]) {
        productMetrics[productId].daily[dateStr] = {
          quantity: 0,
          revenue: 0,
          transaction_count: 0,
          avg_price: 0
        };
      }
      
      const daily = productMetrics[productId].daily[dateStr];
      daily.quantity += item.quantity;
      daily.revenue += item.price;
      daily.transaction_count++;
      daily.avg_price = daily.revenue / daily.quantity;

      // Weekly aggregation
      if (!productMetrics[productId].weekly[weekStr]) {
        productMetrics[productId].weekly[weekStr] = {
          quantity: 0,
          revenue: 0,
          transaction_count: 0,
          avg_price: 0
        };
      }
      
      const weekly = productMetrics[productId].weekly[weekStr];
      weekly.quantity += item.quantity;
      weekly.revenue += item.price;
      weekly.transaction_count++;
      weekly.avg_price = weekly.revenue / weekly.quantity;

      // Monthly aggregation
      if (!productMetrics[productId].monthly[monthStr]) {
        productMetrics[productId].monthly[monthStr] = {
          quantity: 0,
          revenue: 0,
          transaction_count: 0,
          avg_price: 0
        };
      }
      
      const monthly = productMetrics[productId].monthly[monthStr];
      monthly.quantity += item.quantity;
      monthly.revenue += item.price;
      monthly.transaction_count++;
      monthly.avg_price = monthly.revenue / monthly.quantity;
    });

    return productMetrics;
  }

  getWeekString(date) {
    const year = date.getFullYear();
    const week = this.getWeekNumber(date);
    return `${year}-W${week.toString().padStart(2, '0')}`;
  }

  getWeekNumber(date) {
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = d.getUTCDay() || 7;
    d.setUTCDate(d.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
    return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
  }
}

module.exports = { BackgroundIntelligenceEngine };
```

##### **Step 4: Create Vercel Cron Job**
```javascript
// üìÅ app/api/cron/intelligence/route.ts

import { NextRequest, NextResponse } from 'next/server';
const { BackgroundIntelligenceEngine } = require('../../../../services/intelligence/BackgroundIntelligenceEngine');

export async function GET(request: NextRequest) {
  // Verify cron authorization
  const authHeader = request.headers.get('authorization');
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    console.log('üß† Starting scheduled intelligence processing...');
    
    const engine = new BackgroundIntelligenceEngine();
    await engine.processAllRestaurants();
    
    return NextResponse.json({ 
      success: true, 
      message: 'Intelligence processing completed',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Cron job error:', error);
    
    return NextResponse.json({ 
      success: false, 
      error: error.message,
      timestamp: new Date().toISOString()
    }, { status: 500 });
  }
}
```

##### **Step 5: Configure Vercel Cron**
```json
// üìÅ vercel.json
{
  "crons": [
    {
      "path": "/api/cron/intelligence",
      "schedule": "0 2 * * *"
    }
  ]
}
```

##### **Validation Step 3-5:**
```bash
# Test background processing locally
node -e "
const { BackgroundIntelligenceEngine } = require('./services/intelligence/BackgroundIntelligenceEngine');
const engine = new BackgroundIntelligenceEngine();
engine.processRestaurantIntelligence('13207c90-2ea6-4aa0-bfac-349753d24ea4')
  .then(() => console.log('‚úÖ Test completed'))
  .catch(err => console.error('‚ùå Test failed:', err));
"

# Check if metrics were generated
# (Run in Supabase SQL Editor)
SELECT 
  metric_type, 
  time_dimension, 
  COUNT(*) as metric_count,
  AVG(confidence_score) as avg_confidence
FROM intelligent_metrics 
WHERE restaurant_id = '13207c90-2ea6-4aa0-bfac-349753d24ea4'
GROUP BY metric_type, time_dimension;

# Expected output:
# product_performance | daily   | 30+  | 0.8+
# product_performance | weekly  | 4+   | 0.8+
# product_performance | monthly | 3+   | 0.9+
```

#### **DAY 5-7: Smart ProductAnalyzer Integration**

##### **Step 6: Update ProductAnalyzer to Use Intelligent Metrics**
```javascript
// üìÅ services/intelligence/ProductPerformanceAnalyzer.js - UPDATED VERSION

const { createClient } = require('@supabase/supabase-js');

class ProductPerformanceAnalyzer {
  constructor(supabaseUrl, supabaseKey) {
    this.supabase = createClient(supabaseUrl, supabaseKey);
  }

  async analyze(restaurantId, days = 30) {
    console.log(`üìä Analyzing products using intelligent metrics (${days} days)...`);
    
    try {
      // üöÄ NEW APPROACH: Use pre-calculated intelligent metrics
      const useIntelligentMetrics = await this.shouldUseIntelligentMetrics(restaurantId, days);
      
      if (useIntelligentMetrics) {
        console.log('üß† Using intelligent metrics for instant analysis');
        return await this.analyzeUsingIntelligentMetrics(restaurantId, days);
      } else {
        console.log('‚ö° Falling back to real-time analysis');
        return await this.analyzeRealTime(restaurantId, days);
      }
      
    } catch (error) {
      console.error('‚ùå Error in ProductPerformanceAnalyzer:', error);
      // Graceful fallback to real-time analysis
      return await this.analyzeRealTime(restaurantId, days);
    }
  }

  async shouldUseIntelligentMetrics(restaurantId, days) {
    // Check if we have recent intelligent metrics
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - 1); // Metrics should be less than 1 day old
    
    const { data: recentMetrics, error } = await this.supabase
      .from('intelligent_metrics')
      .select('id')
      .eq('restaurant_id', restaurantId)
      .eq('metric_type', 'product_performance')
      .gte('updated_at', cutoffDate.toISOString())
      .limit(1);

    return !error && recentMetrics && recentMetrics.length > 0;
  }

  async analyzeUsingIntelligentMetrics(restaurantId, days) {
    console.log('üß† Fetching pre-calculated intelligent metrics...');
    
    // Calculate date range
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    
    // Get relevant metrics
    const { data: metrics, error } = await this.supabase
      .from('intelligent_metrics')
      .select('*')
      .eq('restaurant_id', restaurantId)
      .eq('metric_type', 'product_performance')
      .gte('time_period', startDate.toISOString().split('T')[0])
      .lte('time_period', endDate.toISOString().split('T')[0])
      .order('time_period', { ascending: false });

    if (error || !metrics || metrics.length === 0) {
      throw new Error('No intelligent metrics available');
    }

    console.log(`üìä Found ${metrics.length} pre-calculated metrics`);

    // Aggregate metrics by product
    const productStats = this.aggregateIntelligentMetrics(metrics, days);
    
    // Get learned patterns
    const patterns = await this.getLearnedPatterns(restaurantId);
    
    // Generate top products
    const topProducts = this.getTopProductsFromStats(productStats);
    
    // Generate contextual insights
    const insights = this.generateIntelligentInsights({
      productStats,
      topProducts,
      patterns,
      totalDays: days,
      metricsCount: metrics.length
    });

    return {
      success: true,
      insights: insights,
      data: {
        topProducts,
        patterns,
        summary: {
          totalProducts: Object.keys(productStats).length,
          totalUnits: Object.values(productStats).reduce((sum, p) => sum + p.quantity, 0),
          totalRevenue: Object.values(productStats).reduce((sum, p) => sum + p.revenue, 0),
          metricsProcessed: metrics.length,
          processingMode: 'intelligent_metrics',
          dateRange: { from: startDate, to: endDate }
        }
      }
    };
  }

  async getLearnedPatterns(restaurantId) {
    const { data: patterns } = await this.supabase
      .from('fudi_learned_patterns')
      .select('*')
      .eq('restaurant_id', restaurantId)
      .gte('confidence', 0.7) // Only high-confidence patterns
      .order('strength', { ascending: false })
      .limit(10);

    return patterns || [];
  }

  aggregateIntelligentMetrics(metrics, days) {
    const productStats = {};
    
    metrics.forEach(metric => {
      const productId = metric.dimensions.product_id;
      const productName = metric.dimensions.product_name || `Product ${productId}`;
      
      if (!productStats[productId]) {
        productStats[productId] = {
          id: productId,
          name: productName,
          quantity: 0,
          revenue: 0,
          transaction_count: 0,
          confidence_score: 0,
          daily_data: []
        };
      }
      
      const stats = productStats[productId];
      stats.quantity += metric.metrics.quantity || 0;
      stats.revenue += metric.metrics.revenue || 0;
      stats.transaction_count += metric.metrics.transaction_count || 0;
      stats.confidence_score = Math.max(stats.confidence_score, metric.confidence_score || 0);
      stats.daily_data.push({
        date: metric.time_period,
        quantity: metric.metrics.quantity || 0,
        revenue: metric.metrics.revenue || 0
      });
    });

    // Calculate derived metrics
    Object.values(productStats).forEach(stats => {
      stats.avgPrice = stats.quantity > 0 ? stats.revenue / stats.quantity : 0;
      stats.dailyAverage = stats.quantity / days;
      stats.reliability = stats.confidence_score;
    });

    return productStats;
  }

  getTopProductsFromStats(productStats) {
    return Object.values(productStats)
      .sort((a, b) => b.revenue - a.revenue)
      .slice(0, 10)
      .map((product, index) => ({
        rank: index + 1,
        id: product.id,
        name: product.name,
        quantity: product.quantity,
        revenue: product.revenue,
        avgPrice: product.avgPrice,
        dailyAverage: product.dailyAverage,
        reliability: product.reliability,
        transactions: product.transaction_count
      }));
  }

  generateIntelligentInsights(analysis) {
    const insights = [];
    const { productStats, topProducts, patterns, totalDays } = analysis;
    
    if (topProducts.length > 0) {
      const star = topProducts[0];
      
      // Enhanced star product insight with pattern data
      insights.push(`üåü **${star.name}** ES tu platillo estrella absoluto con **${star.quantity} unidades** vendidas en ${totalDays} d√≠as`);
      insights.push(`üî• Lidera tu operaci√≥n generando **$${star.revenue.toFixed(2)}** en revenue (precio promedio: $${star.avgPrice.toFixed(2)})`);
      insights.push(`üìä Ritmo de venta: **${star.dailyAverage.toFixed(1)} unidades diarias** - este producto est√° on fire, cabr√≥n`);
      
      // Add pattern insights
      const starPatterns = patterns.filter(p => 
        p.pattern_data.product_id === star.id && p.pattern_type === 'day_of_week'
      );
      
      if (starPatterns.length > 0) {
        const dayPattern = starPatterns[0];
        insights.push(`üìà **Patr√≥n detectado:** ${dayPattern.pattern_name} - vend√©s ${(dayPattern.pattern_data.peak_multiplier * 100 - 100).toFixed(0)}% m√°s los ${dayPattern.pattern_data.peak_day_name}s`);
      }
      
      // Reliability indicator
      if (star.reliability >= 0.9) {
        insights.push(`‚úÖ **Alta confiabilidad:** Datos con ${(star.reliability * 100).toFixed(0)}% de confianza - puedes apostar por este an√°lisis`);
      }
    }

    // Top 3 comparison
    if (topProducts.length >= 3) {
      const top3 = topProducts.slice(0, 3);
      insights.push(`üèÜ **Dominio total:** ${top3[0].name} (${top3[0].quantity} uds) vs ${top3[1].name} (${top3[1].quantity} uds) vs ${top3[2].name} (${top3[2].quantity} uds)`);
    }

    // Pattern-based insights
    if (patterns.length > 0) {
      const strongestPattern = patterns[0];
      if (strongestPattern.pattern_type === 'day_of_week') {
        insights.push(`üîç **Insight inteligente:** Tu patr√≥n m√°s fuerte es "${strongestPattern.pattern_name}" (${(strongestPattern.strength * 100).toFixed(0)}% de fuerza)`);
      }
    }

    // Processing mode indicator
    insights.push(`‚ö° **An√°lisis instant√°neo:** Procesado desde m√©tricas inteligentes pre-calculadas (${analysis.metricsCount} puntos de datos)`);

    return insights;
  }

  // Keep the real-time analysis as fallback
  async analyzeRealTime(restaurantId, days) {
    // ... (existing real-time analysis code)
    console.log('‚ö° Using real-time analysis (fallback mode)');
    
    // Add processing mode indicator
    const result = await this.originalAnalyzeMethod(restaurantId, days);
    if (result.success && result.insights) {
      result.insights.push(`‚ö†Ô∏è **Modo fallback:** An√°lisis en tiempo real (m√©tricas inteligentes no disponibles)`);
    }
    
    return result;
  }
}

module.exports = ProductPerformanceAnalyzer;
```

##### **Validation Step 6:**
```bash
# Test the new ProductAnalyzer
# (Test via FUDI question)
"¬øCu√°l es mi platillo estrella?"

# Expected logs should show:
"üìä Analyzing products using intelligent metrics (30 days)..."
"üß† Using intelligent metrics for instant analysis"
"üìä Found [X] pre-calculated metrics"

# Expected response should include:
"‚ö° **An√°lisis instant√°neo:** Procesado desde m√©tricas inteligentes pre-calculadas"
```

### **WEEK 2: OPTIMIZATION & VALIDATION**

#### **DAY 8-10: Performance Optimization**

##### **Step 7: Query Optimization**
```sql
-- üöÄ OPTIMIZE INTELLIGENT METRICS QUERIES
CREATE INDEX CONCURRENTLY idx_intelligent_metrics_compound 
  ON intelligent_metrics(restaurant_id, metric_type, time_period DESC, confidence_score);

CREATE INDEX CONCURRENTLY idx_intelligent_metrics_recent 
  ON intelligent_metrics(restaurant_id, updated_at DESC) 
  WHERE confidence_score >= 0.8;

-- Analyze query performance
EXPLAIN ANALYZE 
SELECT * FROM intelligent_metrics 
WHERE restaurant_id = '13207c90-2ea6-4aa0-bfac-349753d24ea4'
  AND metric_type = 'product_performance'
  AND time_period >= '2025-04-30'
  AND confidence_score >= 0.8;

-- Expected: Index scan, execution time < 10ms
```

##### **Step 8: Memory & Cache Optimization**
```javascript
// üìÅ services/cache/IntelligenceCache.js

class IntelligenceCache {
  constructor() {
    this.memoryCache = new Map();
    this.maxCacheSize = 1000; // Max cached insights per restaurant
    this.cacheTTL = 3600000; // 1 hour TTL
  }

  // üöÄ SMART CACHING FOR INSTANT RESPONSES
  getCacheKey(restaurantId, queryType, params) {
    return `${restaurantId}:${queryType}:${JSON.stringify(params)}`;
  }

  async getInsights(restaurantId, queryType, params) {
    const cacheKey = this.getCacheKey(restaurantId, queryType, params);
    const cached = this.memoryCache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      console.log('‚ö° Cache hit - instant response');
      return cached.data;
    }
    
    return null;
  }

  async setInsights(restaurantId, queryType, params, data) {
    const cacheKey = this.getCacheKey(restaurantId, queryType, params);
    
    this.memoryCache.set(cacheKey, {
      data: data,
      timestamp: Date.now()
    });
    
    // Cleanup old entries
    if (this.memoryCache.size > this.maxCacheSize) {
      this.cleanup();
    }
  }

  cleanup() {
    const now = Date.now();
    const expiredKeys = [];
    
    for (const [key, value] of this.memoryCache.entries()) {
      if (now - value.timestamp > this.cacheTTL) {
        expiredKeys.push(key);
      }
    }
    
    expiredKeys.forEach(key => this.memoryCache.delete(key));
    console.log(`üßπ Cache cleanup: removed ${expiredKeys.length} expired entries`);
  }
}

module.exports = { IntelligenceCache };
```

#### **DAY 11-14: Integration Testing & Documentation**

##### **Step 9: End-to-End Testing**
```javascript
// üìÅ tests/intelligence/phase1.test.js

const { BackgroundIntelligenceEngine } = require('../../services/intelligence/BackgroundIntelligenceEngine');
const ProductPerformanceAnalyzer = require('../../services/intelligence/ProductPerformanceAnalyzer');

describe('Phase 1: Foundation Testing', () => {
  const testRestaurantId = '13207c90-2ea6-4aa0-bfac-349753d24ea4';
  
  test('Background processing generates intelligent metrics', async () => {
    const engine = new BackgroundIntelligenceEngine();
    
    // Run background processing
    await engine.processRestaurantIntelligence(testRestaurantId);
    
    // Verify metrics were created
    const metrics = await engine.supabase
      .from('intelligent_metrics')
      .select('*')
      .eq('restaurant_id', testRestaurantId)
      .eq('metric_type', 'product_performance');
    
    expect(metrics.data.length).toBeGreaterThan(0);
    expect(metrics.data[0].confidence_score).toBeGreaterThan(0.5);
  });
  
  test('ProductAnalyzer uses intelligent metrics', async () => {
    const analyzer = new ProductPerformanceAnalyzer(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    
    const result = await analyzer.analyze(testRestaurantId, 30);
    
    expect(result.success).toBe(true);
    expect(result.data.summary.processingMode).toBe('intelligent_metrics');
    expect(result.insights.some(insight => 
      insight.includes('An√°lisis instant√°neo')
    )).toBe(true);
  });
  
  test('Pattern discovery finds day-of-week patterns', async () => {
    const engine = new BackgroundIntelligenceEngine();
    
    await engine.discoverDayOfWeekPatterns(testRestaurantId);
    
    const patterns = await engine.supabase
      .from('fudi_learned_patterns')
      .select('*')
      .eq('restaurant_id', testRestaurantId)
      .eq('pattern_type', 'day_of_week');
    
    expect(patterns.data.length).toBeGreaterThan(0);
    expect(patterns.data[0].strength).toBeGreaterThan(0.3);
  });
  
  test('FUDI responds with intelligent insights', async () => {
    // Test the full pipeline through FUDI
    const response = await fetch('/api/chat', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        restaurantId: testRestaurantId,
        message: '¬øCu√°l es mi platillo estrella?'
      })
    });
    
    const data = await response.json();
    
    expect(data.success).toBe(true);
    expect(data.response).toContain('ES tu platillo estrella absoluto');
    expect(data.metadata.processingMode).toBe('neural_fudi_thinking');
  });
});
```

##### **Step 10: Performance Benchmarking**
```javascript
// üìÅ tests/performance/phase1.benchmark.js

const { performance } = require('perf_hooks');

async function benchmarkPhase1() {
  console.log('üèÉ‚Äç‚ôÇÔ∏è Phase 1 Performance Benchmark');
  console.log('=' * 40);
  
  const testRestaurantId = '13207c90-2ea6-4aa0-bfac-349753d24ea4';
  
  // Benchmark 1: Background processing speed
  const startBG = performance.now();
  const engine = new BackgroundIntelligenceEngine();
  await engine.processRestaurantIntelligence(testRestaurantId);
  const endBG = performance.now();
  
  console.log(`üìä Background Processing: ${(endBG - startBG).toFixed(2)}ms`);
  
  // Benchmark 2: Intelligent metrics query speed
  const startIM = performance.now();
  const analyzer = new ProductPerformanceAnalyzer(
    process.env.SUPABASE_URL,
    process.env.SUPABASE_SERVICE_ROLE_KEY
  );
  await analyzer.analyzeUsingIntelligentMetrics(testRestaurantId, 30);
  const endIM = performance.now();
  
  console.log(`‚ö° Intelligent Metrics Query: ${(endIM - startIM).toFixed(2)}ms`);
  
  // Benchmark 3: Real-time vs Intelligent comparison
  const startRT = performance.now();
  await analyzer.analyzeRealTime(testRestaurantId, 30);
  const endRT = performance.now();
  
  console.log(`üêå Real-time Analysis: ${(endRT - startRT).toFixed(2)}ms`);
  console.log(`üöÄ Speed Improvement: ${((endRT - startRT) / (endIM - startIM)).toFixed(1)}x faster`);
  
  // Target benchmarks
  const targets = {
    backgroundProcessing: 60000, // 1 minute max
    intelligentQuery: 1000, // 1 second max
    speedImprovement: 5 // 5x faster minimum
  };
  
  console.log('\nüìã Target Validation:');
  console.log(`Background Processing: ${endBG - startBG < targets.backgroundProcessing ? '‚úÖ' : '‚ùå'} (${targets.backgroundProcessing}ms target)`);
  console.log(`Intelligent Query: ${endIM - startIM < targets.intelligentQuery ? '‚úÖ' : '‚ùå'} (${targets.intelligentQuery}ms target)`);
  console.log(`Speed Improvement: ${(endRT - startRT) / (endIM - startIM) >= targets.speedImprovement ? '‚úÖ' : '‚ùå'} (${targets.speedImprovement}x target)`);
}

// Run benchmark
benchmarkPhase1().catch(console.error);
```

### **PHASE 1 SUCCESS CRITERIA**

#### **‚úÖ FUNCTIONAL REQUIREMENTS**
- [ ] intelligent_metrics table created and populated
- [ ] fudi_learned_patterns table storing discovered patterns  
- [ ] Background processing job running nightly
- [ ] ProductAnalyzer using intelligent metrics (10x+ faster)
- [ ] Day-of-week patterns discovered and stored
- [ ] FUDI responses include pattern-based insights
- [ ] Graceful fallback to real-time analysis

#### **‚úÖ PERFORMANCE REQUIREMENTS**
- [ ] Background processing: <60 seconds per restaurant
- [ ] Intelligent metrics query: <1 second response time
- [ ] Speed improvement: 5x+ faster than real-time analysis
- [ ] Memory usage: <100MB cache per restaurant
- [ ] 99.9% uptime for intelligent metrics system

#### **‚úÖ DATA QUALITY REQUIREMENTS**
- [ ] Confidence scores >0.8 for 80%+ of metrics
- [ ] Pattern strength >0.3 for discovered patterns
- [ ] Zero data leakage between restaurants
- [ ] Graceful handling of missing/corrupt data

---

## üöÄ PHASE 2: AI ENHANCEMENT (4 WEEKS)

### **WEEK 3: SUPABASE AI FUNCTIONS**

#### **DAY 15-17: Vector Embeddings Implementation**

##### **Step 11: Setup Vector Embeddings**
```sql
-- üß† ENABLE VECTOR EXTENSION
CREATE EXTENSION IF NOT EXISTS vector;

-- Create vector embeddings table for pattern matching
CREATE TABLE pattern_embeddings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id UUID NOT NULL,
  pattern_id UUID REFERENCES fudi_learned_patterns(id),
  pattern_type TEXT NOT NULL,
  pattern_vector vector(384), -- OpenAI embedding dimension
  pattern_metadata JSONB,
  similarity_threshold FLOAT DEFAULT 0.8,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  CONSTRAINT pattern_embeddings_restaurant_id_fkey 
    FOREIGN KEY (restaurant_id) REFERENCES restaurants(id)
);

-- Vector similarity index
CREATE INDEX pattern_embeddings_vector_idx 
  ON pattern_embeddings USING ivfflat (pattern_vector vector_cosine_ops);

-- Restaurant isolation index
CREATE INDEX pattern_embeddings_restaurant_idx 
  ON pattern_embeddings(restaurant_id, pattern_type);

-- RLS
ALTER TABLE pattern_embeddings ENABLE ROW LEVEL SECURITY;
CREATE POLICY pattern_embeddings_restaurant_isolation 
  ON pattern_embeddings FOR ALL 
  USING (restaurant_id = current_setting('app.restaurant_id')::UUID);
```

##### **Step 12: AI-Powered Pattern Matching Function**
```sql
-- ü§ñ SUPABASE AI FUNCTION FOR PATTERN SIMILARITY
CREATE OR REPLACE FUNCTION find_similar_patterns(
  target_restaurant_id UUID,
  query_vector vector(384),
  similarity_threshold FLOAT DEFAULT 0.8,
  max_results INTEGER DEFAULT 10
) RETURNS TABLE (
  pattern_id UUID,
  pattern_name TEXT,
  similarity_score FLOAT,
  pattern_data JSONB,
  confidence FLOAT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    flp.id as pattern_id,
    flp.pattern_name,
    1 - (pe.pattern_vector <=> query_vector) as similarity_score,
    flp.pattern_data,
    flp.confidence
  FROM pattern_embeddings pe
  JOIN fudi_learned_patterns flp ON pe.pattern_id = flp.id
  WHERE pe.restaurant_id = target_restaurant_id
    AND 1 - (pe.pattern_vector <=> query_vector) >= similarity_threshold
  ORDER BY pe.pattern_vector <=> query_vector
  LIMIT max_results;
END;
$$ LANGUAGE plpgsql;

-- üìä ADVANCED PRODUCT INTELLIGENCE FUNCTION
CREATE OR REPLACE FUNCTION calculate_product_intelligence(
  target_restaurant_id UUID,
  period_start DATE,
  period_end DATE,
  min_confidence FLOAT DEFAULT 0.7
) RETURNS TABLE (
  product_id INTEGER,
  product_name TEXT,
  intelligence_score FLOAT,
  performance_metrics JSONB,
  ai_insights JSONB,
  trend_direction TEXT,
  confidence_level FLOAT
) AS $$
DECLARE
  date_range_days INTEGER;
  total_revenue FLOAT;
  avg_confidence FLOAT;
BEGIN
  -- Calculate date range
  date_range_days := period_end - period_start;
  
  -- Calculate total revenue for normalization
  SELECT 
    COALESCE(SUM((metrics->>'revenue')::FLOAT), 0),
    COALESCE(AVG(confidence_score), 0)
  INTO total_revenue, avg_confidence
  FROM intelligent_metrics
  WHERE restaurant_id = target_restaurant_id
    AND metric_type = 'product_performance'
    AND time_period BETWEEN period_start AND period_end
    AND confidence_score >= min_confidence;
  
  -- Return enhanced product intelligence
  RETURN QUERY
  SELECT 
    (dimensions->>'product_id')::INTEGER as product_id,
    COALESCE(dimensions->>'product_name', 'Unknown Product') as product_name,
    
    -- Intelligence score (0-1) based on multiple factors
    LEAST(1.0, GREATEST(0.0, 
      -- Revenue weight (40%)
      0.4 * COALESCE((SUM((metrics->>'revenue')::FLOAT) / NULLIF(total_revenue, 0)), 0) +
      -- Consistency weight (30%)
      0.3 * COALESCE(AVG(confidence_score), 0) +
      -- Growth weight (30%)
      0.3 * LEAST(1.0, GREATEST(0.0, 
        CASE 
          WHEN LAG(SUM((metrics->>'quantity')::FLOAT)) OVER (ORDER BY (dimensions->>'product_id')::INTEGER) > 0
          THEN (SUM((metrics->>'quantity')::FLOAT) - LAG(SUM((metrics->>'quantity')::FLOAT)) OVER (ORDER BY (dimensions->>'product_id')::INTEGER)) 
               / LAG(SUM((metrics->>'quantity')::FLOAT)) OVER (ORDER BY (dimensions->>'product_id')::INTEGER)
          ELSE 0.5
        END + 1) / 2
      )
    )) as intelligence_score,
    
    -- Performance metrics aggregation
    jsonb_build_object(
      'total_quantity', COALESCE(SUM((metrics->>'quantity')::FLOAT), 0),
      'total_revenue', COALESCE(SUM((metrics->>'revenue')::FLOAT), 0),
      'avg_price', CASE 
        WHEN SUM((metrics->>'quantity')::FLOAT) > 0 
        THEN SUM((metrics->>'revenue')::FLOAT) / SUM((metrics->>'quantity')::FLOAT)
        ELSE 0 
      END,
      'transaction_count', COALESCE(SUM((metrics->>'transaction_count')::FLOAT), 0),
      'daily_average', CASE 
        WHEN date_range_days > 0 
        THEN SUM((metrics->>'quantity')::FLOAT) / date_range_days
        ELSE 0 
      END,
      'consistency_score', COALESCE(AVG(confidence_score), 0),
      'data_points', COUNT(*)
    ) as performance_metrics,
    
    -- AI-generated insights
    jsonb_build_object(
      'market_position', CASE 
        WHEN SUM((metrics->>'revenue')::FLOAT) / NULLIF(total_revenue, 0) > 0.2 THEN 'dominant'
        WHEN SUM((metrics->>'revenue')::FLOAT) / NULLIF(total_revenue, 0) > 0.1 THEN 'strong'
        WHEN SUM((metrics->>'revenue')::FLOAT) / NULLIF(total_revenue, 0) > 0.05 THEN 'moderate'
        ELSE 'weak'
      END,
      'revenue_concentration', SUM((metrics->>'revenue')::FLOAT) / NULLIF(total_revenue, 0),
      'reliability_rating', CASE 
        WHEN AVG(confidence_score) >= 0.9 THEN 'very_high'
        WHEN AVG(confidence_score) >= 0.8 THEN 'high'
        WHEN AVG(confidence_score) >= 0.7 THEN 'medium'
        ELSE 'low'
      END,
      'recommendation', CASE 
        WHEN SUM((metrics->>'revenue')::FLOAT) / NULLIF(total_revenue, 0) > 0.15 
             AND AVG(confidence_score) >= 0.8 THEN 'promote_heavily'
        WHEN SUM((metrics->>'revenue')::FLOAT) / NULLIF(total_revenue, 0) > 0.1 THEN 'promote_moderately'
        WHEN SUM((metrics->>'revenue')::FLOAT) / NULLIF(total_revenue, 0) > 0.05 THEN 'maintain_current'
        ELSE 'evaluate_discontinuation'
      END
    ) as ai_insights,
    
    -- Trend direction analysis
    CASE 
      WHEN LAG(SUM((metrics->>'quantity')::FLOAT)) OVER (ORDER BY (dimensions->>'product_id')::INTEGER) IS NULL THEN 'insufficient_data'
      WHEN SUM((metrics->>'quantity')::FLOAT) > LAG(SUM((metrics->>'quantity')::FLOAT)) OVER (ORDER BY (dimensions->>'product_id')::INTEGER) * 1.1 THEN 'growing'
      WHEN SUM((metrics->>'quantity')::FLOAT) < LAG(SUM((metrics->>'quantity')::FLOAT)) OVER (ORDER BY (dimensions->>'product_id')::INTEGER) * 0.9 THEN 'declining'
      ELSE 'stable'
    END as trend_direction,
    
    -- Overall confidence level
    COALESCE(AVG(confidence_score), 0) as confidence_level
    
  FROM intelligent_metrics
  WHERE restaurant_id = target_restaurant_id
    AND metric_type = 'product_performance'
    AND time_period BETWEEN period_start AND period_end
    AND confidence_score >= min_confidence
  GROUP BY dimensions->>'product_id', dimensions->>'product_name'
  HAVING SUM((metrics->>'quantity')::FLOAT) > 0
  ORDER BY intelligence_score DESC;
END;
$$ LANGUAGE plpgsql;
```

### **WEEK 4: LEARNING SYSTEM IMPLEMENTATION**

#### **DAY 18-21: FUDI Learning Engine**

##### **Step 13: Create FUDI Learning System**
```javascript
// üìÅ services/intelligence/FudiLearningEngine.js

class FudiLearningEngine {
  constructor(supabase) {
    this.supabase = supabase;
    this.learningVersion = 'v1.0';
  }

  // üß† ANALYZE CONVERSATION QUALITY
  async analyzeConversation(restaurantId, question, response, userFeedback = null) {
    console.log(`üß† Analyzing conversation for ${restaurantId}`);
    
    const conversationAnalysis = {
      question_intent: await this.classifyQuestionIntent(question),
      response_accuracy: await this.scoreResponseAccuracy(response),
      pattern_usage: await this.analyzePatternUsage(restaurantId, response),
      user_satisfaction: userFeedback ? this.parseUserFeedback(userFeedback) : null,
      conversation_timestamp: new Date().toISOString()
    };

    // Store conversation for learning
    await this.storeConversationLearning(restaurantId, {
      question,
      response,
      analysis: conversationAnalysis,
      feedback: userFeedback
    });

    // Update FUDI's restaurant-specific intelligence
    await this.updateRestaurantIntelligence(restaurantId, conversationAnalysis);

    return conversationAnalysis;
  }

  // üéØ CLASSIFY QUESTION INTENT
  async classifyQuestionIntent(question) {
    const intentPatterns = {
      product_analysis: [
        'platillo estrella', 'producto top', 'm√°s vendido', 'bestseller',
        'star product', 'performance', 'an√°lisis producto'
      ],
      temporal_analysis: [
        'temporada', 'mes', 'semana', 'ayer', 'hoy', 'tendencia',
        'comparar', 'vs', 'hist√≥rico', 'seasonal'
      ],
      forecasting: [
        'predice', 'predicci√≥n', 'forecast', 'proyecci√≥n', 'futuro',
        'esperar', 'pr√≥ximo', 'siguiente'
      ],
      optimization: [
        'mejorar', 'optimizar', 'recomendar', 'sugerir', 'estrategia',
        'aumentar', 'incrementar', 'boost'
      ],
      pattern_discovery: [
        'patr√≥n', 'pattern', 'tendencia', 'comportamiento', 'cuando',
        'hora pico', 'd√≠a mejor', 'frecuencia'
      ]
    };

    const questionLower = question.toLowerCase();
    const detectedIntents = [];

    for (const [intent, patterns] of Object.entries(intentPatterns)) {
      const matches = patterns.filter(pattern => 
        questionLower.includes(pattern.toLowerCase())
      );
      
      if (matches.length > 0) {
        detectedIntents.push({
          intent,
          confidence: matches.length / patterns.length,
          matched_patterns: matches
        });
      }
    }

    return {
      primary_intent: detectedIntents.length > 0 ? detectedIntents[0].intent : 'general_inquiry',
      all_intents: detectedIntents,
      intent_confidence: detectedIntents.length > 0 ? detectedIntents[0].confidence : 0.5
    };
  }

  // üìä SCORE RESPONSE ACCURACY
  async scoreResponseAccuracy(response) {
    const qualityIndicators = {
      has_specific_numbers: /\d+(\.\d+)?/.test(response),
      has_product_names: /\*\*[^*]+\*\*/.test(response),
      has_insights: /üåü|üî•|üìä|üìà|üèÜ/.test(response),
      has_confidence_indicator: /confianza|confiabilidad|confidence/.test(response.toLowerCase()),
      has_actionable_advice: /recomiend|suger|optim|mejor/.test(response.toLowerCase()),
      appropriate_length: response.length > 100 && response.length < 2000
    };

    const score = Object.values(qualityIndicators).filter(Boolean).length / Object.keys(qualityIndicators).length;

    return {
      accuracy_score: score,
      quality_indicators: qualityIndicators,
      response_length: response.length,
      contains_data: qualityIndicators.has_specific_numbers,
      contains_insights: qualityIndicators.has_insights
    };
  }

  // üîç ANALYZE PATTERN USAGE
  async analyzePatternUsage(restaurantId, response) {
    // Get restaurant's learned patterns
    const { data: patterns } = await this.supabase
      .from('fudi_learned_patterns')
      .select('*')
      .eq('restaurant_id', restaurantId)
      .gte('confidence', 0.7);

    const usedPatterns = [];
    const responseLower = response.toLowerCase();

    if (patterns) {
      patterns.forEach(pattern => {
        const patternName = pattern.pattern_name.toLowerCase();
        const patternType = pattern.pattern_type;
        
        // Check if pattern was referenced in response
        if (responseLower.includes(patternName) || 
            responseLower.includes(patternType) ||
            (pattern.pattern_data.peak_day_name && 
             responseLower.includes(pattern.pattern_data.peak_day_name.toLowerCase()))) {
          
          usedPatterns.push({
            pattern_id: pattern.id,
            pattern_name: pattern.pattern_name,
            pattern_type: pattern.pattern_type,
            confidence: pattern.confidence,
            strength: pattern.strength
          });
        }
      });
    }

    return {
      patterns_available: patterns ? patterns.length : 0,
      patterns_used: usedPatterns.length,
      pattern_usage_rate: patterns && patterns.length > 0 ? usedPatterns.length / patterns.length : 0,
      used_patterns: usedPatterns
    };
  }

  // üíæ STORE CONVERSATION LEARNING
  async storeConversationLearning(restaurantId, conversationData) {
    const { error } = await this.supabase
      .from('fudi_conversation_learning')
      .insert({
        restaurant_id: restaurantId,
        question: conversationData.question,
        response: conversationData.response,
        conversation_analysis: conversationData.analysis,
        user_feedback: conversationData.feedback,
        learning_version: this.learningVersion,
        created_at: new Date().toISOString()
      });

    if (error) {
      console.error('Error storing conversation learning:', error);
    }
  }

  // üß† UPDATE RESTAURANT-SPECIFIC INTELLIGENCE
  async updateRestaurantIntelligence(restaurantId, analysis) {
    const currentIntelligence = await this.getRestaurantIntelligence(restaurantId);
    
    const updatedIntelligence = {
      ...currentIntelligence,
      total_conversations: (currentIntelligence.total_conversations || 0) + 1,
      avg_response_accuracy: this.calculateRunningAverage(
        currentIntelligence.avg_response_accuracy || 0.5,
        analysis.response_accuracy.accuracy_score,
        currentIntelligence.total_conversations || 0
      ),
      pattern_usage_rate: this.calculateRunningAverage(
        currentIntelligence.pattern_usage_rate || 0,
        analysis.pattern_usage.pattern_usage_rate,
        currentIntelligence.total_conversations || 0
      ),
      primary_question_types: this.updateQuestionTypeFrequency(
        currentIntelligence.primary_question_types || {},
        analysis.question_intent.primary_intent
      ),
      last_updated: new Date().toISOString(),
      learning_version: this.learningVersion
    };

    await this.supabase
      .from('fudi_restaurant_intelligence')
      .upsert({
        restaurant_id: restaurantId,
        intelligence_data: updatedIntelligence,
        updated_at: new Date().toISOString()
      });
  }

  // üìä UTILITY FUNCTIONS
  calculateRunningAverage(currentAvg, newValue, count) {
    if (count === 0) return newValue;
    return (currentAvg * count + newValue) / (count + 1);
  }

  updateQuestionTypeFrequency(currentTypes, newType) {
    const updated = { ...currentTypes };
    updated[newType] = (updated[newType] || 0) + 1;
    return updated;
  }

  async getRestaurantIntelligence(restaurantId) {
    const { data } = await this.supabase
      .from('fudi_restaurant_intelligence')
      .select('intelligence_data')
      .eq('restaurant_id', restaurantId)
      .single();

    return data ? data.intelligence_data : {};
  }

  parseUserFeedback(feedback) {
    // Simple feedback parsing - can be enhanced with NLP
    const positive = ['good', 'great', 'excellent', 'helpful', 'perfect', 'correct'];
    const negative = ['bad', 'wrong', 'incorrect', 'unhelpful', 'useless'];
    
    const feedbackLower = feedback.toLowerCase();
    
    if (positive.some(word => feedbackLower.includes(word))) {
      return { sentiment: 'positive', confidence: 0.8 };
    } else if (negative.some(word => feedbackLower.includes(word))) {
      return { sentiment: 'negative', confidence: 0.8 };
    }
    
    return { sentiment: 'neutral', confidence: 0.5 };
  }
}

module.exports = { FudiLearningEngine };
```

##### **Step 14: Create Conversation Learning Table**
```sql
-- üß† CONVERSATION LEARNING STORAGE
CREATE TABLE fudi_conversation_learning (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id UUID NOT NULL,
  question TEXT NOT NULL,
  response TEXT NOT NULL,
  conversation_analysis JSONB,
  user_feedback TEXT,
  feedback_sentiment TEXT, -- 'positive', 'negative', 'neutral'
  learning_version TEXT DEFAULT 'v1.0',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  CONSTRAINT fudi_conversation_learning_restaurant_id_fkey 
    FOREIGN KEY (restaurant_id) REFERENCES restaurants(id)
);

-- Create indexes for learning analysis
CREATE INDEX idx_fudi_conversation_restaurant 
  ON fudi_conversation_learning(restaurant_id, created_at DESC);
CREATE INDEX idx_fudi_conversation_sentiment 
  ON fudi_conversation_learning(restaurant_id, feedback_sentiment) 
  WHERE feedback_sentiment IS NOT NULL;

-- RLS
ALTER TABLE fudi_conversation_learning ENABLE ROW LEVEL SECURITY;
CREATE POLICY fudi_conversation_learning_isolation 
  ON fudi_conversation_learning FOR ALL 
  USING (restaurant_id = current_setting('app.restaurant_id')::UUID);

-- üß† RESTAURANT INTELLIGENCE STORAGE
CREATE TABLE fudi_restaurant_intelligence (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  restaurant_id UUID NOT NULL UNIQUE,
  intelligence_data JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  CONSTRAINT fudi_restaurant_intelligence_restaurant_id_fkey 
    FOREIGN KEY (restaurant_id) REFERENCES restaurants(id)
);

-- Create indexes
CREATE INDEX idx_fudi_restaurant_intelligence_updated 
  ON fudi_restaurant_intelligence(restaurant_id, updated_at DESC);

-- RLS
ALTER TABLE fudi_restaurant_intelligence ENABLE ROW LEVEL SECURITY;
CREATE POLICY fudi_restaurant_intelligence_isolation 
  ON fudi_restaurant_intelligence FOR ALL 
  USING (restaurant_id = current_setting('app.restaurant_id')::UUID);
```

#### **DAY 22-24: Smart Response Generation**

##### **Step 15: Enhanced Neural Pipeline Integration**
```javascript
// üìÅ services/neural/EnhancedFudiBrain.js

const { FudiLearningEngine } = require('../intelligence/FudiLearningEngine');

class EnhancedFudiBrain {
  constructor(supabase) {
    this.supabase = supabase;
    this.learningEngine = new FudiLearningEngine(supabase);
  }

  // üß† ENHANCED NEURAL PROCESSING WITH LEARNING
  async processWithLearning(restaurantId, question, neuralInsights) {
    console.log(`üß† Processing with learning for ${restaurantId}`);
    
    // 1. Get restaurant-specific intelligence
    const restaurantIntelligence = await this.getRestaurantIntelligence(restaurantId);
    
    // 2. Get learned patterns for this restaurant
    const learnedPatterns = await this.getRelevantPatterns(restaurantId, question);
    
    // 3. Generate context-aware response
    const enhancedResponse = await this.generateContextAwareResponse({
      question,
      neuralInsights,
      restaurantIntelligence,
      learnedPatterns
    });
    
    // 4. Learn from this interaction
    await this.learningEngine.analyzeConversation(
      restaurantId, 
      question, 
      enhancedResponse
    );
    
    return enhancedResponse;
  }

  async getRestaurantIntelligence(restaurantId) {
    const { data } = await this.supabase
      .from('fudi_restaurant_intelligence')
      .select('intelligence_data')
      .eq('restaurant_id', restaurantId)
      .single();

    return data ? data.intelligence_data : this.getDefaultIntelligence();
  }

  async getRelevantPatterns(restaurantId, question) {
    // Get patterns that might be relevant to the question
    const { data: patterns } = await this.supabase
      .from('fudi_learned_patterns')
      .select('*')
      .eq('restaurant_id', restaurantId)
      .gte('confidence', 0.7)
      .order('strength', { ascending: false })
      .limit(5);

    return patterns || [];
  }

  async generateContextAwareResponse({ question, neuralInsights, restaurantIntelligence, learnedPatterns }) {
    // Build enhanced context for Claude
    const contextualData = {
      base_insights: neuralInsights,
      restaurant_profile: {
        conversation_history: restaurantIntelligence.total_conversations || 0,
        preferred_question_types: restaurantIntelligence.primary_question_types || {},
        response_accuracy: restaurantIntelligence.avg_response_accuracy || 0.5,
        pattern_usage_rate: restaurantIntelligence.pattern_usage_rate || 0
      },
      learned_patterns: learnedPatterns.map(pattern => ({
        name: pattern.pattern_name,
        type: pattern.pattern_type,
        strength: pattern.strength,
        confidence: pattern.confidence,
        data: pattern.pattern_data
      })),
      personalization_hints: this.generatePersonalizationHints(restaurantIntelligence)
    };

    // Enhanced prompt for Claude with learning context
    const enhancedPrompt = this.buildEnhancedPrompt(question, contextualData);
    
    // Generate response using enhanced context
    const response = await this.callClaudeWithEnhancedContext(enhancedPrompt);
    
    return response;
  }

  generatePersonalizationHints(intelligence) {
    const hints = [];
    
    // Communication style adaptation
    if (intelligence.avg_response_accuracy > 0.8) {
      hints.push('maintain_detailed_analysis');
    } else {
      hints.push('simplify_explanations');
    }
    
    // Pattern usage optimization
    if (intelligence.pattern_usage_rate > 0.6) {
      hints.push('emphasize_patterns');
    } else {
      hints.push('introduce_patterns_gradually');
    }
    
    // Question type adaptation
    const topQuestionType = this.getTopQuestionType(intelligence.primary_question_types || {});
    if (topQuestionType) {
      hints.push(`optimize_for_${topQuestionType}`);
    }
    
    return hints;
  }

  buildEnhancedPrompt(question, contextualData) {
    return `
ENHANCED FUDI CONTEXT:
Restaurant Profile:
- Conversations: ${contextualData.restaurant_profile.conversation_history}
- Accuracy