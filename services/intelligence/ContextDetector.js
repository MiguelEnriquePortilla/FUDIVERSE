// üß† CONTEXT DETECTOR - CEREBRO DE FUDI
// Detecta la intenci√≥n y contexto del usuario ANTES de responder

class ContextDetector {
  constructor() {
    this.patterns = {
      // MODO CASUAL - Saludos, conversaci√≥n social
      casual: [
        /^(hola|hey|buenas|qu√© tal|buenos d√≠as|buenas tardes|buenas noches)/i,
        /^(¬ø?c√≥mo est√°s|¬ø?qu√© tal|¬ø?c√≥mo va todo|¬ø?todo bien)/i,
        /^(gracias|perfecto|genial|excelente|ok|vale)$/i,
        /^(adi√≥s|nos vemos|hasta luego|chao|bye)/i,
        /^(s√≠|si|no|claro|obvio|por supuesto)$/i
      ],
      
      // MODO CONSULTIVO - Preguntas abiertas, opiniones
      consultivo: [
        /¬ø?qu√© opinas|¬ø?qu√© piensas|¬ø?qu√© te parece|¬ø?qu√© crees/i,
        /¬ø?me puedes ayudar|¬ø?puedes ayudarme|¬ø?necesito ayuda/i,
        /¬ø?qu√© me recomiendas|¬ø?qu√© sugieres|¬ø?alguna sugerencia/i,
        /¬ø?c√≥mo puedo|¬ø?c√≥mo debo|¬ø?qu√© deber√≠a/i,
        /¬ø?es buena idea|¬ø?te parece bien|¬ø?est√° bien si/i,
        /estrategia|plan|planear|planificar/i
      ],
      
      // MODO ANAL√çTICO - Datos espec√≠ficos, m√©tricas, reportes
      analitico: [
        /¬ø?(c√≥mo van|c√≥mo est√°n|c√≥mo estuvieron).*(ventas|ingresos|ganancias)/i,
        /¬ø?(cu√°l|cu√°les).*(mejor|peor|m√°s|menos).*(platillo|producto|vendido)/i,
        /¬ø?(cu√°nto|cu√°ntos).*(vendimos|ganamos|perdimos)/i,
        /ventas|revenue|ingresos|ganancias|profit|platillo|producto/i,
        /ayer|hoy|esta semana|este mes|√∫ltimo|anterior/i,
        /n√∫meros|datos|estad√≠sticas|m√©tricas|reporte|an√°lisis/i,
        /tickets|clientes|promedio|total|porcentaje/i
      ],
      
      // MODO URGENTE - Problemas, crisis, necesidades inmediatas
      urgente: [
        /urgente|emergencia|problema|crisis|ayuda/i,
        /no funciona|no est√° funcionando|est√° mal|error/i,
        /necesito.*(ya|ahora|inmediatamente|r√°pido)/i,
        /¬ø?qu√© hago|¬ø?qu√© paso|¬ø?por qu√©/i,
        /perdiendo|bajando|cayendo|mal/i
      ]
    };

    this.contextCache = new Map(); // Cache para optimizaci√≥n
  }

  /**
   * Detecta el contexto principal del mensaje
   * @param {string} message - Mensaje del usuario
   * @param {object} conversationHistory - Historial de conversaci√≥n
   * @returns {object} - Contexto detectado con confianza
   */
  detectContext(message, conversationHistory = []) {
    const cacheKey = this.getCacheKey(message, conversationHistory);
    
    // Verificar cache
    if (this.contextCache.has(cacheKey)) {
      return this.contextCache.get(cacheKey);
    }

    const context = this.analyzeMessage(message, conversationHistory);
    
    // Cachear resultado
    this.contextCache.set(cacheKey, context);
    
    return context;
  }

  /**
   * Analiza el mensaje y determina contexto
   */
  analyzeMessage(message, conversationHistory) {
    const normalizedMessage = message.toLowerCase().trim();
    
    // DETECCI√ìN POR PATRONES
    const scores = {
      casual: this.calculatePatternScore(normalizedMessage, this.patterns.casual),
      consultivo: this.calculatePatternScore(normalizedMessage, this.patterns.consultivo),
      analitico: this.calculatePatternScore(normalizedMessage, this.patterns.analitico),
      urgente: this.calculatePatternScore(normalizedMessage, this.patterns.urgente)
    };

    // AN√ÅLISIS CONTEXTUAL ADICIONAL
    const contextualAnalysis = this.analyzeContextualFactors(message, conversationHistory);
    
    // COMBINAR SCORES
    const finalScores = this.combineScores(scores, contextualAnalysis);
    
    // DETERMINAR CONTEXTO GANADOR
    const primaryContext = this.determinePrimaryContext(finalScores);
    
    return {
      primary: primaryContext.type,
      confidence: primaryContext.confidence,
      scores: finalScores,
      metadata: {
        messageLength: message.length,
        hasQuestion: message.includes('?'),
        hasNumbers: /\d/.test(message),
        conversationLength: conversationHistory.length,
        analysis: contextualAnalysis
      }
    };
  }

  /**
   * Calcula score basado en patrones regex
   */
  calculatePatternScore(message, patterns) {
    let score = 0;
    let matches = 0;

    for (const pattern of patterns) {
      if (pattern.test(message)) {
        matches++;
        // Score m√°s alto para matches m√°s espec√≠ficos
        score += pattern.source.length > 20 ? 0.8 : 0.6;
      }
    }

    // Normalizar score
    return Math.min(score, 1.0);
  }

  /**
   * Analiza factores contextuales adicionales
   */
  analyzeContextualFactors(message, conversationHistory) {
    const factors = {
      messageLength: this.analyzeMessageLength(message),
      questionType: this.analyzeQuestionType(message),
      temporalReferences: this.analyzeTemporalReferences(message),
      businessTerms: this.analyzeBusinessTerms(message),
      emotionalTone: this.analyzeEmotionalTone(message),
      conversationFlow: this.analyzeConversationFlow(conversationHistory)
    };

    return factors;
  }

  /**
   * Analiza la longitud del mensaje
   */
  analyzeMessageLength(message) {
    const length = message.length;
    
    if (length < 10) return { type: 'short', casualBias: 0.3 };
    if (length < 50) return { type: 'medium', casualBias: 0.1 };
    return { type: 'long', consultivoBias: 0.2 };
  }

  /**
   * Analiza el tipo de pregunta
   */
  analyzeQuestionType(message) {
    if (!message.includes('?')) return { type: 'statement', bias: 0 };
    
    if (/^(qu√©|cu√°l|cu√°les|cu√°nto|cu√°ntos)/i.test(message)) {
      return { type: 'specific', analiticoBias: 0.3 };
    }
    
    if (/^(c√≥mo|por qu√©|para qu√©)/i.test(message)) {
      return { type: 'consultive', consultivoBias: 0.3 };
    }
    
    return { type: 'general', bias: 0 };
  }

  /**
   * Detecta referencias temporales
   */
  analyzeTemporalReferences(message) {
    const temporalTerms = /ayer|hoy|ma√±ana|esta semana|este mes|√∫ltimo|anterior|ahora|actualmente/i;
    
    if (temporalTerms.test(message)) {
      return { hasTemporal: true, analiticoBias: 0.4 };
    }
    
    return { hasTemporal: false, bias: 0 };
  }

  /**
   * Detecta t√©rminos de negocio
   */
  analyzeBusinessTerms(message) {
    const businessTerms = /ventas|ingresos|ganancias|clientes|productos|platillos|tickets|promedio|total/i;
    
    if (businessTerms.test(message)) {
      return { hasBusinessTerms: true, analiticoBias: 0.3 };
    }
    
    return { hasBusinessTerms: false, bias: 0 };
  }

  /**
   * Analiza tono emocional
   */
  analyzeEmotionalTone(message) {
    const urgentTerms = /problema|urgente|ayuda|mal|error|no funciona|crisis|emergencia/i;
    const helpTerms = /necesito|ayuda|puedes|ayudar|ay√∫dame|socorro/i;
    const positiveTerms = /gracias|perfecto|genial|excelente|bueno/i;
    
    let tone = 'neutral';
    let needsHelp = false;
    let urgenteBias = 0;
    let consultivoBias = 0;
    
    if (urgentTerms.test(message)) {
      tone = 'urgent';
      urgenteBias = 0.8; // BOOST M√ÅXIMO para urgente
    }
    
    if (helpTerms.test(message)) {
      needsHelp = true;
      consultivoBias = 0.6; // BOOST FUERTE para consultivo
      if (tone !== 'urgent') tone = 'needs_help';
    }
    
    if (positiveTerms.test(message)) {
      if (tone === 'neutral') tone = 'positive';
      return { tone: 'positive', casualBias: 0.2 };
    }
    
    return { 
      tone, 
      needsHelp,
      urgenteBias,
      consultivoBias
    };
  }

  /**
   * Analiza el flujo de conversaci√≥n
   */
  analyzeConversationFlow(conversationHistory) {
    if (conversationHistory.length === 0) {
      return { isFirstMessage: true, casualBias: 0.2 };
    }
    
    const lastMessage = conversationHistory[conversationHistory.length - 1];
    
    // Si el √∫ltimo mensaje de Fudi fue una pregunta, el usuario probablemente est√° respondiendo
    if (lastMessage && lastMessage.type === 'assistant' && lastMessage.content.includes('?')) {
      return { isResponse: true, consultivoBias: 0.3 };
    }
    
    return { isFollowUp: true, bias: 0 };
  }

  /**
   * Combina scores de patrones con an√°lisis contextual
   */
  combineScores(patternScores, contextualAnalysis) {
    const finalScores = { ...patternScores };
    
    // BOOST CR√çTICO: Palabras de intenci√≥n DOMINAN sobre palabras de dominio
    const intentBoosts = this.calculateIntentionBoosts(contextualAnalysis);
    
    // Aplicar boosts de intenci√≥n PRIMERO (m√°s peso)
    if (intentBoosts.urgente > 0) {
      finalScores.urgente += intentBoosts.urgente;
      console.log(`üö® URGENTE BOOST aplicado: +${intentBoosts.urgente}`);
    }
    
    if (intentBoosts.consultivo > 0) {
      finalScores.consultivo += intentBoosts.consultivo;
      console.log(`ü§ù CONSULTIVO BOOST aplicado: +${intentBoosts.consultivo}`);
    }
    
    // Aplicar bias contextual (menor peso)
    Object.keys(contextualAnalysis).forEach(factor => {
      const analysis = contextualAnalysis[factor];
      
      if (analysis.casualBias) {
        finalScores.casual += analysis.casualBias * 0.5; // Reducido para no interferir
      }
      if (analysis.consultivoBias && intentBoosts.consultivo === 0) {
        finalScores.consultivo += analysis.consultivoBias * 0.7;
      }
      if (analysis.analiticoBias && intentBoosts.urgente === 0) {
        finalScores.analitico += analysis.analiticoBias * 0.7;
      }
      if (analysis.urgenteBias) {
        finalScores.urgente += analysis.urgenteBias * 0.3; // Ya manejado arriba
      }
    });

    // Normalizar scores finales
    Object.keys(finalScores).forEach(key => {
      finalScores[key] = Math.min(finalScores[key], 1.0);
    });

    return finalScores;
  }

  /**
   * NUEVO: Calcula boosts de intenci√≥n cr√≠ticos
   */
  calculateIntentionBoosts(contextualAnalysis) {
    const boosts = {
      urgente: 0,
      consultivo: 0
    };

    // Detectar intenciones cr√≠ticas que deben DOMINAR
    const emotionalTone = contextualAnalysis.emotionalTone;
    const businessTerms = contextualAnalysis.businessTerms;
    
    // BOOST URGENTE: Si hay tono urgente, DEBE ganar
    if (emotionalTone && emotionalTone.tone === 'urgent') {
      boosts.urgente = 0.7; // BOOST MASIVO
      console.log('üö® Detected URGENT intention - applying dominance boost');
    }
    
    // BOOST CONSULTIVO: Palabras de ayuda/necesidad
    if (emotionalTone && (
      emotionalTone.needsHelp || 
      contextualAnalysis.conversationFlow?.isHelpRequest
    )) {
      boosts.consultivo = 0.6; // BOOST FUERTE
      console.log('ü§ù Detected CONSULTIVE intention - applying help boost');
    }

    return boosts;
  }

  /**
   * Determina el contexto primario basado en scores
   */
  determinePrimaryContext(scores) {
    const entries = Object.entries(scores);
    entries.sort((a, b) => b[1] - a[1]);
    
    const winner = entries[0];
    const runnerUp = entries[1];
    
    // Calcular confianza basada en diferencia entre primer y segundo lugar
    const confidence = Math.min(0.9, winner[1] + (winner[1] - runnerUp[1]) * 0.5);
    
    return {
      type: winner[0],
      confidence: Math.max(0.1, confidence), // M√≠nimo 10% de confianza
      runner_up: runnerUp[0],
      margin: winner[1] - runnerUp[1]
    };
  }

  /**
   * Genera cache key para optimizaci√≥n
   */
  getCacheKey(message, conversationHistory) {
    const historyLength = conversationHistory.length;
    const lastMessageType = historyLength > 0 ? conversationHistory[historyLength - 1].type : 'none';
    
    return `${message.toLowerCase().trim()}_${historyLength}_${lastMessageType}`;
  }

  /**
   * Limpia cache (llamar peri√≥dicamente)
   */
  clearCache() {
    this.contextCache.clear();
  }

  /**
   * M√©todo de utilidad para testing
   */
  testContext(message) {
    const result = this.detectContext(message, []);
    
    console.log(`üß† Context Detection Test:`);
    console.log(`Message: "${message}"`);
    console.log(`Primary Context: ${result.primary} (${Math.round(result.confidence * 100)}% confidence)`);
    console.log(`Scores:`, result.scores);
    console.log(`Metadata:`, result.metadata);
    
    return result;
  }
}

module.exports = { ContextDetector };